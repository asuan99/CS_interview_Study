# 알고리즘 & 자료구조

# DFS, BFS

### DFS와 BFS에 대해 설명해주세요

- DFS(Depth-First Search)
    - 깊이 우선 탐색
        
        그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
        
    - 스택 자료구조(혹은 재귀함수)를 이용
    - 동작 과정
        1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
        2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리
            
            방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드 꺼냄
            
        3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복
- BFS(Breadth-First Search)
    - 너비 우선 탐색
        
        그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘
        
    - 큐 자료구조를 이용
    - 동작 과정
        1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
        2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에는 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
        3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복
- 각각의 장단점
    
    ![difference](img/difference.png)
    
    - DFS
        - 장점
            - 현 경로상의 노드들만 기억하면 되므로 저장공간 수요가 비교적 적다
            - 목표 노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있다.
        - 단점
            - 해가 없는 경로가 깊을 경우 탐색시간이 오래 걸릴 수 있다.
            - 얻어진 해가 최단 경로가 된다는 보장이 없다.
            - 깊이가 무한히 깊어지면 스택오버플로우 발생 가능
                
                깊이 제한을 두는 방법으로 해결 가능
                
    - BFS
        - 장점
            - 너비를 우선으로 탐색하므로 답이 되는 경로가 여러 개인 경우에도 최단경로를 얻을 수 있다.
            - 경로가 무한히 깊어져도 최단경로를 반드시 찾을 수 있다.
            - 노드 수가 적고 깊이가 얕은 해가 존재할 때 유리
        - 단점
            - dfs와 달리 큐를 이용하여 다음에 탐색할 정점들을 저장하므로 더 큰 저장공간이 필요


***
### DFS와 BFS의 적용 예시

>💡 검색 대상 그래프가 정말 크다면 → DFS


>💡 검색 대상 그래프의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 → BFS



- 그래프의 모든 정점을 방문하는 것이 주요한 문제
    
    단순히 모든 정점을 방문하는 것이 중요한 문제의 경우 dfs, bfs 두 가지 방법 중 어느 것을 사용해도 상관이 없다.
    
    두 방식 모두 조건 내의 모든 노드를 검색하기 때문
    
- 경로의 특징을 저장해둬야 하는 문제
    
    예를 들어 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 땐 DFS 사용
    
    BFS는 다음에 탐색할 정점들을 큐에 다 저장하므로 경로의 특징을 저장할 수 없다.
    
- 최단거리를 구하는 문제
    
    미로찾기 등 최단 거리를 구해야 할 경우 BFS가 유리
    
    DFS로 경로를 탐색하는 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있다.
    
    BFS는 현재 노드부터 가까운 곳부터 찾기 때문에 경로 탐색 시 먼저 찾아지는 해답이 곧 최단거리이다.
    

***
- 꼬리 질문
1. DFS와 BFS를 구현할 때 주로 사용하는 자료구조는 무엇인가요?
    
    DFS → 스택
    
    BFS → 큐
    
2. DFS와 BFS의 시간 복잡도는 어떻게 되나요?
    
    인접행렬로 구현한 경우 : O(n^2)
    
    인접리스트로 구현한 경우 : O(n+e)
    
3. DFS를 적용할 수 있는 또 다른 경우는 무엇인가요?
    
    사이클(순환)의 존재 여부를 확인할 때 사용
    
    깊이를 우선적으로 탐색하므로 하나의 방향이 잡히면 그 방향의 끝에 도달할 때까지 탐색한다
    
    따라서 사이클이 존재하는 방향만 찾으면 바로 사이클 확인 가능


- 참고자료
    
    [DFS, BFS의 설명, 차이점](https://velog.io/@lucky-korma/DFS-BFS의-설명-차이점)
    
    [[알고리즘] 깊이 우선 탐색(DFS) 과 너비 우선 탐색(BFS)](https://velog.io/@cha-suyeon/알고리즘-깊이-우선-탐색DFS-과-너비-우선-탐색BFS)
    
    [dfs와 bfs를 구현하는 여러가지 방법 in python](https://velog.io/@tks7205/dfs와-bfs를-구현하는-여러가지-방법-in-python)

    [[알고리즘] 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)](https://currygamedev.tistory.com/10)